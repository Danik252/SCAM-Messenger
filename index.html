<!doctype html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SCAM Messenger ‚Äî –æ–¥–∏–Ω —Ñ–∞–π–ª</title>
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
  <style>
    :root { color-scheme: dark; }
    .scrollbar::-webkit-scrollbar{ width:10px; height:10px; }
    .scrollbar::-webkit-scrollbar-thumb{ background:#2a3447; border-radius:999px; }
    .scrollbar::-webkit-scrollbar-track{ background:#0b1020; }
    .safe-wrap { overflow-wrap:anywhere; word-break:break-word; }
    .ring { animation: ring 1.2s infinite; }
    @keyframes ring { 0%{transform:translateY(0)} 10%{transform:translateY(-1px)} 20%{transform:translateY(0)} 30%{transform:translateY(-1px)} 40%{transform:translateY(0)} 50%{transform:translateY(-1px)} 60%{transform:translateY(0)} 100%{transform:translateY(0)} }
  </style>
</head>
<body class="min-h-screen bg-slate-950 text-slate-100">
  <div class="max-w-6xl mx-auto p-4">
    <header class="flex items-center justify-between gap-3 mb-4">
      <div class="flex items-center gap-3">
        <div class="w-10 h-10 rounded-2xl bg-gradient-to-br from-fuchsia-500 to-cyan-400 grid place-items-center font-black text-slate-900">SC</div>
        <div>
          <div class="text-lg font-semibold leading-tight">SCAM Messenger</div>
          <div class="text-xs text-slate-400">–û–¥–∏–Ω HTML —Ñ–∞–π–ª (–¥–µ–º–æ –±–µ–∑ —Å–µ—Ä–≤–µ—Ä–∞). –ß–∞—Ç—ã/–∞–∫–∫–∞—É–Ω—Ç—ã —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –≤ <span class="font-mono">localStorage</span>.</div>
        </div>
      </div>
      <div id="topActions" class="hidden items-center gap-2">
        <button id="btnProfile" class="px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700 text-sm">–ü—Ä–æ—Ñ–∏–ª—å</button>
        <button id="btnLogout" class="px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700 text-sm">–í—ã–π—Ç–∏</button>
      </div>
    </header>

    <div id="bannerLimitations" class="mb-4 rounded-2xl border border-amber-500/30 bg-amber-500/10 p-3 text-sm text-amber-100/90">
      <div class="font-semibold">–í–∞–∂–Ω–æ (–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –±–µ–∑ —Å–µ—Ä–≤–µ—Ä–∞):</div>
      <ul class="list-disc pl-5 mt-1 space-y-1 text-amber-100/80">
        <li>–≠—Ç–æ –æ—Ñ–ª–∞–π–Ω-–¥–µ–º–æ: –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Ä–∞–±–æ—Ç–∞—é—Ç, –µ—Å–ª–∏ –æ—Ç–∫—Ä—ã—Ç—å —Å–∞–π—Ç <span class="font-semibold">–≤ —Ä–∞–∑–Ω—ã—Ö –≤–∫–ª–∞–¥–∫–∞—Ö/–æ–∫–Ω–∞—Ö</span> –æ–¥–Ω–æ–≥–æ –±—Ä–∞—É–∑–µ—Ä–∞ (—Å–≤—è–∑—å —á–µ—Ä–µ–∑ <span class="font-mono">BroadcastChannel</span>).</li>
        <li>–í—ã–ª–æ–∂–∏—Ç—å –Ω–∞ GitHub Pages –º–æ–∂–Ω–æ, –Ω–æ <span class="font-semibold">–º–µ–∂–¥—É —Ä–∞–∑–Ω—ã–º–∏ –ª—é–¥—å–º–∏/—É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞–º–∏</span> –Ω—É–∂–Ω—ã —Å–µ—Ä–≤–µ—Ä(–∞) —Å–∏–≥–Ω–∞–ª–∏–Ω–≥–∞/–ë–î (–∏–Ω–∞—á–µ –Ω–µ –±—É–¥–µ—Ç —Ä–µ–∞–ª—å–Ω–æ–≥–æ –æ–Ω–ª–∞–π–Ω–∞).</li>
        <li>–ü–∞—Ä–æ–ª–∏ –Ω–µ –∑–∞—â–∏—â–µ–Ω—ã –∫–∞–∫ –≤ –Ω–∞—Å—Ç–æ—è—â–µ–º —Å–µ—Ä–≤–∏—Å–µ (—Ç–æ–ª—å–∫–æ –ª–æ–∫–∞–ª—å–Ω–∞—è —Ö–µ—à-–ø—Ä–æ–≤–µ—Ä–∫–∞).</li>
      </ul>
    </div>

    <!-- AUTH -->
    <section id="authView" class="grid md:grid-cols-2 gap-4">
      <div class="rounded-2xl border border-slate-800 bg-slate-900/40 p-4">
        <div class="text-xl font-semibold mb-1">–í—Ö–æ–¥</div>
        <div class="text-sm text-slate-400 mb-4">–í–æ–π—Ç–∏ –≤ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∞–∫–∫–∞—É–Ω—Ç (–≤ —ç—Ç–æ–º –±—Ä–∞—É–∑–µ—Ä–µ).</div>
        <form id="loginForm" class="space-y-3">
          <div>
            <label class="block text-sm text-slate-300 mb-1">–ù–∏–∫ –∏–ª–∏ ID</label>
            <input id="loginIdentifier" class="w-full px-3 py-2 rounded-xl bg-slate-950/60 border border-slate-800 focus:outline-none focus:ring-2 focus:ring-cyan-500" placeholder="–Ω–∞–ø—Ä–∏–º–µ—Ä: SCAM-AB12CD –∏–ª–∏ nik" required />
          </div>
          <div>
            <label class="block text-sm text-slate-300 mb-1">–ü–∞—Ä–æ–ª—å</label>
            <input id="loginPassword" type="password" class="w-full px-3 py-2 rounded-xl bg-slate-950/60 border border-slate-800 focus:outline-none focus:ring-2 focus:ring-cyan-500" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" required />
          </div>
          <button class="w-full px-3 py-2 rounded-xl bg-cyan-500 hover:bg-cyan-400 text-slate-950 font-semibold">–í–æ–π—Ç–∏</button>
          <div id="loginError" class="hidden text-sm text-rose-300"></div>
        </form>
      </div>

      <div class="rounded-2xl border border-slate-800 bg-slate-900/40 p-4">
        <div class="text-xl font-semibold mb-1">–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è</div>
        <div class="text-sm text-slate-400 mb-4">–°–æ–∑–¥–∞–π –Ω–æ–≤—ã–π –∞–∫–∫–∞—É–Ω—Ç. –í—Å—ë —Å–æ—Ö—Ä–∞–Ω–∏—Ç—Å—è –ª–æ–∫–∞–ª—å–Ω–æ.</div>
        <form id="registerForm" class="space-y-3">
          <div>
            <label class="block text-sm text-slate-300 mb-1">–ù–∏–∫</label>
            <input id="regNick" class="w-full px-3 py-2 rounded-xl bg-slate-950/60 border border-slate-800 focus:outline-none focus:ring-2 focus:ring-fuchsia-500" placeholder="—Ç–≤–æ–π –Ω–∏–∫" required />
            <div class="text-xs text-slate-500 mt-1">–ù–∏–∫ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —É–Ω–∏–∫–∞–ª—å–Ω—ã–º –≤ —ç—Ç–æ–º –±—Ä–∞—É–∑–µ—Ä–µ.</div>
          </div>
          <div>
            <label class="block text-sm text-slate-300 mb-1">–ü–∞—Ä–æ–ª—å</label>
            <input id="regPassword" type="password" class="w-full px-3 py-2 rounded-xl bg-slate-950/60 border border-slate-800 focus:outline-none focus:ring-2 focus:ring-fuchsia-500" placeholder="–ø—Ä–∏–¥—É–º–∞–π –ø–∞—Ä–æ–ª—å" required />
          </div>
          <div>
            <label class="block text-sm text-slate-300 mb-1">–ê–≤–∞—Ç–∞—Ä (—Ñ–∞–π–ª —Å –ü–ö, –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)</label>
            <input id="regAvatar" type="file" accept="image/*" class="w-full text-sm" />
          </div>
          <button class="w-full px-3 py-2 rounded-xl bg-fuchsia-500 hover:bg-fuchsia-400 text-slate-950 font-semibold">–°–æ–∑–¥–∞—Ç—å –∞–∫–∫–∞—É–Ω—Ç</button>
          <div id="regError" class="hidden text-sm text-rose-300"></div>
        </form>
      </div>
    </section>

    <!-- APP -->
    <section id="appView" class="hidden">
      <div class="grid lg:grid-cols-[360px_1fr] gap-4">
        <!-- Sidebar -->
        <aside class="rounded-2xl border border-slate-800 bg-slate-900/40 p-3 flex flex-col min-h-[70vh]">
          <div class="flex items-center gap-3 p-2 rounded-xl bg-slate-950/30 border border-slate-800">
            <img id="meAvatar" alt="" class="w-10 h-10 rounded-xl object-cover border border-slate-700" />
            <div class="min-w-0">
              <div class="flex items-center gap-2">
                <div id="meNick" class="font-semibold truncate"></div>
                <span id="meId" class="text-xs text-slate-400 font-mono truncate"></span>
              </div>
              <div class="text-xs text-slate-500">–ù–∞–∂–º–∏ ¬´–ü—Ä–æ—Ñ–∏–ª—å¬ª —á—Ç–æ–±—ã –º–µ–Ω—è—Ç—å –Ω–∏–∫/–∞–≤–∞—Ç–∞—Ä.</div>
            </div>
          </div>

          <div class="mt-3">
            <label class="text-xs text-slate-400">–ü–æ–∏—Å–∫ –ø–æ –Ω–∏–∫—É –∏–ª–∏ ID</label>
            <div class="mt-1 flex gap-2">
              <input id="searchInput" class="flex-1 px-3 py-2 rounded-xl bg-slate-950/60 border border-slate-800 focus:outline-none focus:ring-2 focus:ring-cyan-500" placeholder="–≤–≤–µ–¥–∏ –Ω–∏–∫ –∏–ª–∏ SCAM-..." />
              <button id="btnSearchClear" class="px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700">√ó</button>
            </div>
            <div id="searchResults" class="mt-2 hidden rounded-xl border border-slate-800 bg-slate-950/40 overflow-hidden"></div>
          </div>

          <div class="mt-3">
            <div class="text-xs text-slate-400 mb-2">–ß–∞—Ç—ã</div>
            <div class="space-y-2">
              <button id="btnGlobal" class="w-full text-left px-3 py-2 rounded-xl border border-slate-800 bg-slate-950/40 hover:bg-slate-950/60">
                <div class="flex items-center justify-between">
                  <div class="font-semibold"># –û–±—â–∏–π —á–∞—Ç</div>
                  <div class="text-xs text-slate-500">–±–µ–∑ –∑–≤–æ–Ω–∫–æ–≤</div>
                </div>
                <div class="text-xs text-slate-400">–¢—É—Ç –º–æ–≥—É—Ç –ø–∏—Å–∞—Ç—å –≤—Å–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏.</div>
              </button>
            </div>
          </div>

          <div class="mt-4 flex-1 min-h-0">
            <div class="flex items-center justify-between mb-2">
              <div class="text-xs text-slate-400">–õ–∏—á–Ω—ã–µ —á–∞—Ç—ã</div>
              <button id="btnRefreshChats" class="text-xs px-2 py-1 rounded-lg bg-slate-800 hover:bg-slate-700 border border-slate-700">–æ–±–Ω–æ–≤–∏—Ç—å</button>
            </div>
            <div id="dmList" class="space-y-2 overflow-auto scrollbar pr-1 max-h-[45vh]"></div>
          </div>

          <div class="mt-3 text-xs text-slate-500">
            –ü–æ–¥—Å–∫–∞–∑–∫–∞: –æ—Ç–∫—Ä–æ–π —Å–∞–π—Ç –≤ –¥–≤—É—Ö –≤–∫–ª–∞–¥–∫–∞—Ö, —Å–æ–∑–¥–∞–π –¥–≤–∞ –∞–∫–∫–∞—É–Ω—Ç–∞ –∏ –ø–æ–æ–±—â–∞–π—Å—è/–ø–æ–∑–≤–æ–Ω–∏.
          </div>
        </aside>

        <!-- Chat -->
        <main class="rounded-2xl border border-slate-800 bg-slate-900/40 p-3 flex flex-col min-h-[70vh]">
          <div class="flex items-center justify-between gap-2 p-2 rounded-xl bg-slate-950/30 border border-slate-800">
            <div class="flex items-center gap-3 min-w-0">
              <img id="chatAvatar" alt="" class="w-10 h-10 rounded-xl object-cover border border-slate-700" />
              <div class="min-w-0">
                <div id="chatTitle" class="font-semibold truncate"># –û–±—â–∏–π —á–∞—Ç</div>
                <div id="chatSubtitle" class="text-xs text-slate-400 truncate">–ó–¥–µ—Å—å –º–æ–≥—É—Ç –æ–±—â–∞—Ç—å—Å—è –≤—Å–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏</div>
              </div>
            </div>
            <div class="flex items-center gap-2">
              <button id="btnCall" class="px-3 py-2 rounded-xl bg-emerald-500 hover:bg-emerald-400 text-slate-950 font-semibold disabled:opacity-40 disabled:cursor-not-allowed">–ó–≤–æ–Ω–æ–∫</button>
              <button id="btnHangup" class="hidden px-3 py-2 rounded-xl bg-rose-500 hover:bg-rose-400 text-slate-950 font-semibold">–°–±—Ä–æ—Å–∏—Ç—å</button>
            </div>
          </div>

          <div id="messages" class="mt-3 flex-1 min-h-0 overflow-auto scrollbar pr-1 space-y-2"></div>

          <div class="mt-3">
            <div id="composerNotice" class="hidden mb-2 text-xs rounded-xl border border-amber-500/30 bg-amber-500/10 p-2 text-amber-100/80"></div>
            <div class="flex items-end gap-2">
              <button id="btnEmoji" class="px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700">üòä</button>
              <textarea id="msgInput" rows="1" class="flex-1 px-3 py-2 rounded-xl bg-slate-950/60 border border-slate-800 focus:outline-none focus:ring-2 focus:ring-cyan-500 resize-none scrollbar" placeholder="–ù–∞–ø–∏—à–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ..."></textarea>
              <button id="btnSend" class="px-4 py-2 rounded-xl bg-cyan-500 hover:bg-cyan-400 text-slate-950 font-semibold">–û—Ç–ø—Ä–∞–≤–∏—Ç—å</button>
            </div>
            <div class="mt-2 text-xs text-slate-500">–í –æ–±—â–∏–π —á–∞—Ç –∑–≤–æ–Ω–∏—Ç—å –Ω–µ–ª—å–∑—è. –°–µ–±–µ –ø–∏—Å–∞—Ç—å –Ω–µ–ª—å–∑—è (–≤ –ª–∏—á–∫–µ).</div>
          </div>
        </main>
      </div>
    </section>
  </div>

  <!-- EMOJI POPOVER -->
  <div id="emojiPopover" class="hidden fixed inset-0">
    <div class="absolute inset-0 bg-black/60" data-close="emoji"></div>
    <div class="absolute bottom-6 left-1/2 -translate-x-1/2 w-[min(560px,92vw)] rounded-2xl border border-slate-800 bg-slate-900 p-3">
      <div class="flex items-center justify-between mb-2">
        <div class="font-semibold">–≠–º–æ–¥–∑–∏</div>
        <button class="px-2 py-1 rounded-lg bg-slate-800 hover:bg-slate-700 border border-slate-700" data-close="emoji">–ó–∞–∫—Ä—ã—Ç—å</button>
      </div>
      <div id="emojiGrid" class="grid grid-cols-10 sm:grid-cols-12 gap-2"></div>
    </div>
  </div>

  <!-- PROFILE MODAL -->
  <div id="profileModal" class="hidden fixed inset-0">
    <div class="absolute inset-0 bg-black/60" data-close="profile"></div>
    <div class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-[min(680px,92vw)] rounded-2xl border border-slate-800 bg-slate-900 p-4">
      <div class="flex items-start justify-between gap-3">
        <div>
          <div class="text-xl font-semibold">–ü—Ä–æ—Ñ–∏–ª—å</div>
          <div class="text-sm text-slate-400">–ú–µ–Ω—è–π –Ω–∏–∫/–∞–≤–∞—Ç–∞—Ä. –¢–≤–æ–π ID –Ω—É–∂–µ–Ω —á—Ç–æ–±—ã —Ç–µ–±—è –Ω–∞—à–ª–∏.</div>
        </div>
        <button class="px-2 py-1 rounded-lg bg-slate-800 hover:bg-slate-700 border border-slate-700" data-close="profile">–ó–∞–∫—Ä—ã—Ç—å</button>
      </div>

      <div class="mt-4 grid md:grid-cols-[160px_1fr] gap-4">
        <div class="rounded-2xl border border-slate-800 bg-slate-950/40 p-3">
          <img id="profileAvatar" class="w-full aspect-square rounded-2xl object-cover border border-slate-700" alt="" />
          <div class="mt-2">
            <input id="profileAvatarFile" type="file" accept="image/*" class="w-full text-sm" />
          </div>
          <button id="btnRemoveAvatar" class="mt-2 w-full px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700 text-sm">–°–±—Ä–æ—Å–∏—Ç—å –∞–≤–∞—Ç–∞—Ä</button>
        </div>

        <div class="rounded-2xl border border-slate-800 bg-slate-950/40 p-3">
          <div class="grid gap-3">
            <div>
              <label class="block text-sm text-slate-300 mb-1">–ù–∏–∫</label>
              <input id="profileNick" class="w-full px-3 py-2 rounded-xl bg-slate-950/60 border border-slate-800 focus:outline-none focus:ring-2 focus:ring-fuchsia-500" />
              <div class="text-xs text-slate-500 mt-1">–ù–∏–∫ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —É–Ω–∏–∫–∞–ª—å–Ω—ã–º.</div>
            </div>
            <div>
              <label class="block text-sm text-slate-300 mb-1">ID (–ø–æ –Ω–µ–º—É —Ç–µ–±—è –Ω–∞–π–¥—É—Ç)</label>
              <div class="flex gap-2">
                <input id="profileId" readonly class="flex-1 px-3 py-2 rounded-xl bg-slate-950/60 border border-slate-800 font-mono text-sm" />
                <button id="btnCopyId" class="px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700 text-sm">–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
              </div>
            </div>
            <div class="flex gap-2">
              <button id="btnSaveProfile" class="px-3 py-2 rounded-xl bg-fuchsia-500 hover:bg-fuchsia-400 text-slate-950 font-semibold">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
              <button id="btnCancelProfile" class="px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700">–û—Ç–º–µ–Ω–∞</button>
            </div>
            <div id="profileError" class="hidden text-sm text-rose-300"></div>
            <div class="text-xs text-slate-500">
              –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –µ—Å–ª–∏ –æ—Ç–∫—Ä–æ–µ—à—å —Å–∞–π—Ç –≤ –¥—Ä—É–≥–æ–π –≤–∫–ª–∞–¥–∫–µ –∏ –≤–æ–π–¥—ë—à—å –¥—Ä—É–≥–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º ‚Äî –º–æ–∂–Ω–æ –±—É–¥–µ—Ç –Ω–∞–π—Ç–∏ —Ç–µ–±—è –ø–æ –Ω–∏–∫—É/ID.
            </div>
          </div>
        </div>
      </div>

    </div>
  </div>

  <!-- INCOMING CALL MODAL -->
  <div id="incomingCallModal" class="hidden fixed inset-0">
    <div class="absolute inset-0 bg-black/70"></div>
    <div class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-[min(520px,92vw)] rounded-2xl border border-slate-800 bg-slate-900 p-4">
      <div class="flex items-center gap-3">
        <img id="incomingAvatar" class="w-12 h-12 rounded-2xl object-cover border border-slate-700" alt="" />
        <div class="min-w-0">
          <div class="text-lg font-semibold ring" id="incomingTitle">–í—Ö–æ–¥—è—â–∏–π –∑–≤–æ–Ω–æ–∫‚Ä¶</div>
          <div class="text-sm text-slate-400 truncate" id="incomingSubtitle"></div>
        </div>
      </div>
      <div class="mt-4 flex gap-2 justify-end">
        <button id="btnDecline" class="px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700">–û—Ç–∫–ª–æ–Ω–∏—Ç—å</button>
        <button id="btnAccept" class="px-3 py-2 rounded-xl bg-emerald-500 hover:bg-emerald-400 text-slate-950 font-semibold">–ü—Ä–∏–Ω—è—Ç—å</button>
      </div>
      <div class="mt-3 text-xs text-slate-500">–ü—Ä–∏ –ø—Ä–∏–Ω—è—Ç–∏–∏ –±—Ä–∞—É–∑–µ—Ä —Å–ø—Ä–æ—Å–∏—Ç —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –Ω–∞ –º–∏–∫—Ä–æ—Ñ–æ–Ω/–∫–∞–º–µ—Ä—É.</div>
    </div>
  </div>

  <!-- CALL OVERLAY -->
  <div id="callOverlay" class="hidden fixed inset-x-0 bottom-0 p-3">
    <div class="max-w-6xl mx-auto rounded-2xl border border-slate-800 bg-slate-950/90 backdrop-blur p-3">
      <div class="flex items-center justify-between gap-3">
        <div class="min-w-0">
          <div class="font-semibold truncate" id="callWith">–ó–≤–æ–Ω–æ–∫</div>
          <div class="text-xs text-slate-400" id="callStatus">–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ‚Ä¶</div>
        </div>
        <div class="flex items-center gap-2">
          <button id="btnToggleMic" class="px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700 text-sm">–ú–∏–∫—Ä–æ—Ñ–æ–Ω: –í–ö–õ</button>
          <button id="btnToggleCam" class="px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700 text-sm">–ö–∞–º–µ—Ä–∞: –í–ö–õ</button>
          <button id="btnToggleScreen" class="px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700 text-sm">–≠–∫—Ä–∞–Ω: –í–´–ö–õ</button>
          <button id="btnHangup2" class="px-3 py-2 rounded-xl bg-rose-500 hover:bg-rose-400 text-slate-950 font-semibold">–°–±—Ä–æ—Å–∏—Ç—å</button>
        </div>
      </div>
      <div class="mt-3 grid md:grid-cols-2 gap-3">
        <div class="rounded-2xl border border-slate-800 bg-slate-900/30 p-2">
          <div class="text-xs text-slate-400 mb-1">–£–¥–∞–ª—ë–Ω–Ω–æ–µ –≤–∏–¥–µ–æ</div>
          <video id="remoteVideo" autoplay playsinline class="w-full aspect-video bg-black rounded-xl"></video>
        </div>
        <div class="rounded-2xl border border-slate-800 bg-slate-900/30 p-2">
          <div class="text-xs text-slate-400 mb-1">–¢–≤–æ—ë –≤–∏–¥–µ–æ</div>
          <video id="localVideo" autoplay muted playsinline class="w-full aspect-video bg-black rounded-xl"></video>
        </div>
      </div>
    </div>
  </div>

  <script>
    // =========================
    // Storage keys
    // =========================
    const K_USERS = 'scam_users_v1';
    const K_SESSION = 'scam_session_v1';
    const K_GLOBAL = 'scam_global_messages_v1';
    const K_LAST_BROADCAST = 'scam_broadcast_last_v1';

    // =========================
    // Utilities
    // =========================
    const $ = (sel) => document.querySelector(sel);
    const escapeHtml = (s) => (s ?? '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
    const now = () => Date.now();
    const fmtTime = (ts) => {
      const d = new Date(ts);
      const hh = String(d.getHours()).padStart(2,'0');
      const mm = String(d.getMinutes()).padStart(2,'0');
      return `${hh}:${mm}`;
    };
    const randomId = () => {
      const alphabet = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
      let s = '';
      for (let i=0;i<8;i++) s += alphabet[Math.floor(Math.random()*alphabet.length)];
      return 'SCAM-' + s;
    };
    const sortPair = (a,b) => [a,b].sort().join('_');
    const dmKey = (a,b) => `scam_dm_v1_${sortPair(a,b)}`;

    function loadJson(key, fallback) {
      try {
        const raw = localStorage.getItem(key);
        return raw ? JSON.parse(raw) : fallback;
      } catch { return fallback; }
    }
    function saveJson(key, value) {
      localStorage.setItem(key, JSON.stringify(value));
    }

    function loadUsers() {
      return loadJson(K_USERS, []);
    }
    function saveUsers(users) {
      saveJson(K_USERS, users);
    }
    function getUserById(id) {
      return loadUsers().find(u => u.id === id) || null;
    }
    function getUserByNick(nick) {
      const n = (nick||'').trim().toLowerCase();
      return loadUsers().find(u => (u.nick||'').toLowerCase() === n) || null;
    }

    function defaultAvatarDataUrl(seed) {
      // simple generated SVG avatar
      const bg = ['#22c55e','#06b6d4','#a855f7','#f97316','#e11d48','#eab308'][Math.abs(hashCode(seed)) % 6];
      const fg = '#0b1020';
      const initials = (seed||'SC').trim().slice(0,2).toUpperCase();
      const svg = `<?xml version="1.0" encoding="UTF-8"?>
      <svg xmlns="http://www.w3.org/2000/svg" width="256" height="256">
        <defs>
          <linearGradient id="g" x1="0" y1="0" x2="1" y2="1">
            <stop offset="0" stop-color="${bg}" stop-opacity="1"/>
            <stop offset="1" stop-color="#38bdf8" stop-opacity="0.65"/>
          </linearGradient>
        </defs>
        <rect width="256" height="256" rx="48" fill="url(#g)"/>
        <text x="50%" y="54%" text-anchor="middle" dominant-baseline="middle" font-family="ui-sans-serif, system-ui" font-weight="800" font-size="88" fill="${fg}">${escapeHtml(initials)}</text>
      </svg>`;
      return 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svg);
    }
    function hashCode(str) {
      let h = 0;
      for (let i=0;i<str.length;i++) h = ((h<<5)-h) + str.charCodeAt(i), h |= 0;
      return h;
    }

    async function sha256Base64(text) {
      const enc = new TextEncoder().encode(text);
      const buf = await crypto.subtle.digest('SHA-256', enc);
      const bytes = new Uint8Array(buf);
      let bin = '';
      for (const b of bytes) bin += String.fromCharCode(b);
      return btoa(bin);
    }

    async function fileToDataUrl(file) {
      return new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onload = () => resolve(r.result);
        r.onerror = reject;
        r.readAsDataURL(file);
      });
    }

    function toast(msg, type='info') {
      // Minimal inline toast
      const el = document.createElement('div');
      el.className = `fixed z-50 left-1/2 -translate-x-1/2 top-4 px-3 py-2 rounded-xl border text-sm shadow-lg ${type==='error' ? 'bg-rose-500/15 border-rose-500/30 text-rose-100' : 'bg-slate-900 border-slate-700 text-slate-100'}`;
      el.textContent = msg;
      document.body.appendChild(el);
      setTimeout(() => { el.style.opacity = '0'; el.style.transition = 'opacity .25s'; }, 2400);
      setTimeout(() => el.remove(), 2800);
    }

    // =========================
    // Broadcast (tabs) ‚Äî BroadcastChannel + localStorage event fallback
    // =========================
    const BC_NAME = 'scam_messenger_bc_v1';
    const bc = ('BroadcastChannel' in window) ? new BroadcastChannel(BC_NAME) : null;
    function broadcast(payload) {
      const msg = { ...payload, _ts: now(), _nonce: Math.random().toString(36).slice(2) };
      if (bc) bc.postMessage(msg);
      // localStorage event fallback
      localStorage.setItem(K_LAST_BROADCAST, JSON.stringify(msg));
    }

    function onBroadcast(msg) {
      if (!msg || msg._seenBy === state.user?.id) return;
      handleBroadcast(msg);
    }

    if (bc) bc.onmessage = (e) => onBroadcast(e.data);
    window.addEventListener('storage', (e) => {
      if (e.key === K_LAST_BROADCAST && e.newValue) {
        try { onBroadcast(JSON.parse(e.newValue)); } catch {}
      }
    });

    // =========================
    // App state
    // =========================
    const state = {
      user: null,
      activeChat: { type: 'global', peerId: null },
      pendingCall: null, // { from, offerSdp, meta }
      call: {
        inCall: false,
        outgoing: false,
        peerId: null,
        pc: null,
        localStream: null,
        remoteStream: null,
        screenStream: null,
        micOn: true,
        camOn: true,
        screenOn: false,
        iceQueue: [],
        remoteDescSet: false,
      }
    };

    // =========================
    // Messages persistence
    // =========================
    function loadGlobalMessages() {
      return loadJson(K_GLOBAL, []);
    }
    function saveGlobalMessages(msgs) {
      saveJson(K_GLOBAL, msgs);
    }
    function loadDmMessages(myId, peerId) {
      return loadJson(dmKey(myId, peerId), []);
    }
    function saveDmMessages(myId, peerId, msgs) {
      saveJson(dmKey(myId, peerId), msgs);
    }

    // =========================
    // DOM references
    // =========================
    const authView = $('#authView');
    const appView = $('#appView');
    const topActions = $('#topActions');

    const loginForm = $('#loginForm');
    const loginIdentifier = $('#loginIdentifier');
    const loginPassword = $('#loginPassword');
    const loginError = $('#loginError');

    const registerForm = $('#registerForm');
    const regNick = $('#regNick');
    const regPassword = $('#regPassword');
    const regAvatar = $('#regAvatar');
    const regError = $('#regError');

    const meAvatar = $('#meAvatar');
    const meNick = $('#meNick');
    const meId = $('#meId');

    const searchInput = $('#searchInput');
    const btnSearchClear = $('#btnSearchClear');
    const searchResults = $('#searchResults');

    const btnGlobal = $('#btnGlobal');
    const dmList = $('#dmList');
    const btnRefreshChats = $('#btnRefreshChats');

    const chatAvatar = $('#chatAvatar');
    const chatTitle = $('#chatTitle');
    const chatSubtitle = $('#chatSubtitle');

    const messagesEl = $('#messages');
    const msgInput = $('#msgInput');
    const btnSend = $('#btnSend');
    const btnEmoji = $('#btnEmoji');
    const composerNotice = $('#composerNotice');

    const emojiPopover = $('#emojiPopover');
    const emojiGrid = $('#emojiGrid');

    const btnProfile = $('#btnProfile');
    const btnLogout = $('#btnLogout');

    const profileModal = $('#profileModal');
    const profileAvatar = $('#profileAvatar');
    const profileAvatarFile = $('#profileAvatarFile');
    const btnRemoveAvatar = $('#btnRemoveAvatar');
    const profileNick = $('#profileNick');
    const profileId = $('#profileId');
    const btnCopyId = $('#btnCopyId');
    const btnSaveProfile = $('#btnSaveProfile');
    const btnCancelProfile = $('#btnCancelProfile');
    const profileError = $('#profileError');

    const btnCall = $('#btnCall');
    const btnHangup = $('#btnHangup');

    const incomingCallModal = $('#incomingCallModal');
    const incomingAvatar = $('#incomingAvatar');
    const incomingTitle = $('#incomingTitle');
    const incomingSubtitle = $('#incomingSubtitle');
    const btnDecline = $('#btnDecline');
    const btnAccept = $('#btnAccept');

    const callOverlay = $('#callOverlay');
    const callWith = $('#callWith');
    const callStatus = $('#callStatus');
    const btnToggleMic = $('#btnToggleMic');
    const btnToggleCam = $('#btnToggleCam');
    const btnToggleScreen = $('#btnToggleScreen');
    const btnHangup2 = $('#btnHangup2');
    const remoteVideo = $('#remoteVideo');
    const localVideo = $('#localVideo');

    // =========================
    // Emoji setup
    // =========================
    const EMOJIS = [
      'üòÄ','üòÅ','üòÇ','ü§£','üòÖ','üòä','üòç','üòò','üòé','ü§©','ü•≥','üò¥',
      'üò°','ü•∂','ü§Ø','üò≠','üò±','ü§î','üôÉ','üòá','ü§°','üíÄ','üëª','ü§ñ',
      'üëç','üëé','üôè','üëè','ü§ù','üí™','üî•','üí•','‚ú®','üåà','üéâ','üíØ',
      '‚ù§Ô∏è','üíî','üíï','üò∫','üò∏','üôà','üôâ','üôä','üçï','üçî','üçü','‚òï',
      '‚ö°','üéß','üéÆ','üìû','üì∑','üé•','üß†','üß©','üóø','ü´°','ü´∂','üß®'
    ];
    function renderEmojiGrid() {
      emojiGrid.innerHTML = '';
      for (const e of EMOJIS) {
        const b = document.createElement('button');
        b.className = 'text-xl p-2 rounded-xl bg-slate-950/40 hover:bg-slate-950/70 border border-slate-800';
        b.textContent = e;
        b.addEventListener('click', () => {
          insertAtCursor(msgInput, e);
          hideEmoji();
          msgInput.focus();
        });
        emojiGrid.appendChild(b);
      }
    }
    function insertAtCursor(textarea, text) {
      const start = textarea.selectionStart ?? textarea.value.length;
      const end = textarea.selectionEnd ?? textarea.value.length;
      textarea.value = textarea.value.slice(0,start) + text + textarea.value.slice(end);
      const pos = start + text.length;
      textarea.selectionStart = textarea.selectionEnd = pos;
      autoGrow(textarea);
    }

    function showEmoji() { emojiPopover.classList.remove('hidden'); }
    function hideEmoji() { emojiPopover.classList.add('hidden'); }

    // =========================
    // Rendering
    // =========================
    function setComposerNotice(text) {
      if (!text) {
        composerNotice.classList.add('hidden');
        composerNotice.textContent = '';
        return;
      }
      composerNotice.textContent = text;
      composerNotice.classList.remove('hidden');
    }

    function renderMe() {
      const u = state.user;
      meAvatar.src = u.avatar || defaultAvatarDataUrl(u.nick || u.id);
      meNick.textContent = u.nick;
      meId.textContent = u.id;
    }

    function getActiveChatInfo() {
      if (state.activeChat.type === 'global') {
        return { title: '# –û–±—â–∏–π —á–∞—Ç', subtitle: '–ó–¥–µ—Å—å –º–æ–≥—É—Ç –æ–±—â–∞—Ç—å—Å—è –≤—Å–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏', avatar: defaultAvatarDataUrl('#') };
      }
      const peer = getUserById(state.activeChat.peerId);
      if (!peer) {
        return { title: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω', subtitle: '–í–æ–∑–º–æ–∂–Ω–æ, –µ–≥–æ —É–¥–∞–ª–∏–ª–∏', avatar: defaultAvatarDataUrl('?') };
      }
      return { title: peer.nick, subtitle: peer.id, avatar: peer.avatar || defaultAvatarDataUrl(peer.nick) };
    }

    function renderChatHeader() {
      const info = getActiveChatInfo();
      chatTitle.textContent = info.title;
      chatSubtitle.textContent = info.subtitle;
      chatAvatar.src = info.avatar;

      const isGlobal = state.activeChat.type === 'global';
      btnCall.disabled = isGlobal || !state.activeChat.peerId || state.activeChat.peerId === state.user.id;
      if (isGlobal) {
        setComposerNotice('–û–±—â–∏–π —á–∞—Ç: –∑–≤–æ–Ω–∫–∏ –∑–∞–ø—Ä–µ—â–µ–Ω—ã.');
      } else {
        setComposerNotice(null);
      }
    }

    function renderMessages() {
      messagesEl.innerHTML = '';
      const myId = state.user.id;
      let msgs = [];
      if (state.activeChat.type === 'global') {
        msgs = loadGlobalMessages();
      } else {
        msgs = loadDmMessages(myId, state.activeChat.peerId);
      }

      for (const m of msgs) {
        const fromUser = getUserById(m.from);
        const isMe = m.from === myId;

        const wrap = document.createElement('div');
        wrap.className = `flex gap-2 ${isMe ? 'justify-end' : 'justify-start'}`;

        const bubble = document.createElement('div');
        bubble.className = `max-w-[85%] rounded-2xl border ${isMe ? 'bg-cyan-500/15 border-cyan-500/30' : 'bg-slate-950/40 border-slate-800'} p-2`;

        const top = document.createElement('div');
        top.className = 'flex items-center justify-between gap-2 mb-1';

        const nameBtn = document.createElement('button');
        nameBtn.className = `text-xs font-semibold ${isMe ? 'text-cyan-200' : 'text-slate-200'} hover:underline truncate`;
        nameBtn.textContent = fromUser ? fromUser.nick : 'Unknown';
        nameBtn.title = fromUser ? `${fromUser.nick} (${fromUser.id})` : 'Unknown';
        nameBtn.dataset.userid = m.from;
        nameBtn.dataset.action = 'openUserChatFromMessage';

        const time = document.createElement('div');
        time.className = 'text-[11px] text-slate-400 shrink-0';
        time.textContent = fmtTime(m.ts);

        top.appendChild(nameBtn);
        top.appendChild(time);

        const text = document.createElement('div');
        text.className = 'text-sm safe-wrap whitespace-pre-wrap';
        text.textContent = m.text;

        bubble.appendChild(top);
        bubble.appendChild(text);

        if (!isMe) {
          const ava = document.createElement('img');
          ava.className = 'w-8 h-8 rounded-xl object-cover border border-slate-700 mt-auto';
          ava.src = (fromUser?.avatar) || defaultAvatarDataUrl(fromUser?.nick || '??');
          wrap.appendChild(ava);
          wrap.appendChild(bubble);
        } else {
          wrap.appendChild(bubble);
        }

        messagesEl.appendChild(wrap);
      }

      scrollMessagesToBottom();
    }

    function scrollMessagesToBottom() {
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    function findDmPeersForUser(myId) {
      const peers = new Set();
      for (let i=0;i<localStorage.length;i++) {
        const k = localStorage.key(i);
        if (!k || !k.startsWith('scam_dm_v1_')) continue;
        const pair = k.replace('scam_dm_v1_','');
        const [a,b] = pair.split('_');
        if (a === myId && b) peers.add(b);
        if (b === myId && a) peers.add(a);
      }
      return [...peers];
    }

    function lastMessagePreview(msgs) {
      if (!msgs?.length) return '';
      const m = msgs[msgs.length-1];
      const u = getUserById(m.from);
      const who = u ? u.nick : 'Unknown';
      return `${who}: ${m.text}`.slice(0, 70);
    }

    function renderDmList() {
      const myId = state.user.id;
      const peers = findDmPeersForUser(myId)
        .map(id => getUserById(id))
        .filter(Boolean)
        .sort((a,b) => (a.nick||'').localeCompare(b.nick||''));

      dmList.innerHTML = '';

      if (!peers.length) {
        const empty = document.createElement('div');
        empty.className = 'text-sm text-slate-500 p-3 rounded-xl border border-slate-800 bg-slate-950/30';
        empty.textContent = '–õ–∏—á–Ω—ã—Ö —á–∞—Ç–æ–≤ –ø–æ–∫–∞ –Ω–µ—Ç. –ù–∞–π–¥–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ –Ω–∏–∫—É/ID –∏ –æ—Ç–∫—Ä–æ–π —á–∞—Ç.';
        dmList.appendChild(empty);
        return;
      }

      for (const peer of peers) {
        const btn = document.createElement('button');
        btn.className = `w-full text-left px-3 py-2 rounded-xl border ${state.activeChat.type==='dm' && state.activeChat.peerId===peer.id ? 'border-cyan-500/40 bg-cyan-500/10' : 'border-slate-800 bg-slate-950/30 hover:bg-slate-950/50'}`;
        btn.dataset.peer = peer.id;

        const msgs = loadDmMessages(myId, peer.id);

        btn.innerHTML = `
          <div class="flex items-center gap-3">
            <img class="w-10 h-10 rounded-xl object-cover border border-slate-700" src="${peer.avatar || defaultAvatarDataUrl(peer.nick)}" alt="" />
            <div class="min-w-0 flex-1">
              <div class="flex items-center justify-between gap-2">
                <div class="font-semibold truncate">${escapeHtml(peer.nick)}</div>
                <div class="text-[11px] text-slate-500 font-mono truncate">${escapeHtml(peer.id)}</div>
              </div>
              <div class="text-xs text-slate-400 truncate">${escapeHtml(lastMessagePreview(msgs))}</div>
            </div>
          </div>
        `;
        btn.addEventListener('click', () => openDm(peer.id));
        dmList.appendChild(btn);
      }
    }

    function renderSearchResults(items) {
      if (!items.length) {
        searchResults.innerHTML = '<div class="p-3 text-sm text-slate-400">–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.</div>';
        searchResults.classList.remove('hidden');
        return;
      }
      searchResults.innerHTML = '';
      for (const u of items) {
        const row = document.createElement('button');
        row.className = 'w-full text-left px-3 py-2 hover:bg-slate-800/50 flex items-center gap-3';
        row.innerHTML = `
          <img class="w-9 h-9 rounded-xl object-cover border border-slate-700" src="${u.avatar || defaultAvatarDataUrl(u.nick)}" alt="" />
          <div class="min-w-0">
            <div class="font-semibold truncate">${escapeHtml(u.nick)}</div>
            <div class="text-xs text-slate-500 font-mono truncate">${escapeHtml(u.id)}</div>
          </div>
        `;
        row.addEventListener('click', () => {
          searchResults.classList.add('hidden');
          searchInput.value = '';
          openDm(u.id);
        });
        searchResults.appendChild(row);
      }
      searchResults.classList.remove('hidden');
    }

    function renderAll() {
      renderMe();
      renderChatHeader();
      renderMessages();
      renderDmList();
    }

    // =========================
    // Auth
    // =========================
    function setAuthError(el, text) {
      if (!text) { el.classList.add('hidden'); el.textContent=''; return; }
      el.textContent = text;
      el.classList.remove('hidden');
    }

    async function register(nick, pass, avatarDataUrl) {
      nick = (nick||'').trim();
      if (nick.length < 2) throw new Error('–ù–∏–∫ —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π (–º–∏–Ω–∏–º—É–º 2 —Å–∏–º–≤–æ–ª–∞).');
      const users = loadUsers();
      if (users.some(u => (u.nick||'').toLowerCase() === nick.toLowerCase())) throw new Error('–≠—Ç–æ—Ç –Ω–∏–∫ —É–∂–µ –∑–∞–Ω—è—Ç.');

      const id = randomId();
      const passHash = await sha256Base64(`${nick}:${pass}`);
      const u = {
        id,
        nick,
        passHash,
        avatar: avatarDataUrl || defaultAvatarDataUrl(nick),
        createdAt: now(),
        updatedAt: now()
      };
      users.push(u);
      saveUsers(users);
      broadcast({ type: 'user:created', userId: id });
      return u;
    }

    async function login(identifier, pass) {
      identifier = (identifier||'').trim();
      const users = loadUsers();
      let u = users.find(x => x.id === identifier) || users.find(x => (x.nick||'').toLowerCase() === identifier.toLowerCase());
      if (!u) throw new Error('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.');
      const passHash = await sha256Base64(`${u.nick}:${pass}`);
      if (passHash !== u.passHash) throw new Error('–ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å.');
      return u;
    }

    function setSession(userId) {
      saveJson(K_SESSION, { userId, ts: now() });
    }
    function clearSession() {
      localStorage.removeItem(K_SESSION);
    }
    function loadSession() {
      return loadJson(K_SESSION, null);
    }

    function showApp() {
      authView.classList.add('hidden');
      appView.classList.remove('hidden');
      topActions.classList.remove('hidden');
      topActions.classList.add('flex');
    }
    function showAuth() {
      authView.classList.remove('hidden');
      appView.classList.add('hidden');
      topActions.classList.add('hidden');
      topActions.classList.remove('flex');
    }

    // =========================
    // Chat actions
    // =========================
    function openGlobal() {
      state.activeChat = { type: 'global', peerId: null };
      renderChatHeader();
      renderMessages();
      renderDmList();
    }

    function openDm(peerId) {
      if (peerId === state.user.id) {
        toast('–ù–µ–ª—å–∑—è –æ—Ç–∫—Ä—ã—Ç—å —á–∞—Ç —Å —Å–∞–º–∏–º —Å–æ–±–æ–π.', 'error');
        return;
      }
      const peer = getUserById(peerId);
      if (!peer) {
        toast('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.', 'error');
        return;
      }
      state.activeChat = { type: 'dm', peerId };
      renderChatHeader();
      renderMessages();
      renderDmList();
    }

    function sendMessage(text) {
      const myId = state.user.id;
      text = (text||'').replace(/\r\n/g,'\n').trim();
      if (!text) return;

      if (state.activeChat.type === 'dm' && state.activeChat.peerId === myId) {
        toast('–ù–µ–ª—å–∑—è –ø–∏—Å–∞—Ç—å —Å–∞–º–æ–º—É —Å–µ–±–µ.', 'error');
        return;
      }

      const m = {
        id: 'm_' + Math.random().toString(36).slice(2) + '_' + now(),
        from: myId,
        to: state.activeChat.type === 'dm' ? state.activeChat.peerId : null,
        text,
        ts: now(),
        chatType: state.activeChat.type
      };

      if (state.activeChat.type === 'global') {
        const msgs = loadGlobalMessages();
        msgs.push(m);
        saveGlobalMessages(msgs);
        broadcast({ type: 'msg:global', message: m });
      } else {
        const peerId = state.activeChat.peerId;
        const msgs = loadDmMessages(myId, peerId);
        msgs.push(m);
        saveDmMessages(myId, peerId, msgs);
        broadcast({ type: 'msg:dm', pair: sortPair(myId, peerId), message: m });
      }

      msgInput.value = '';
      autoGrow(msgInput);
      renderMessages();
      renderDmList();
    }

    // click on nickname inside global chat to open DM
    messagesEl.addEventListener('click', (e) => {
      const btn = e.target.closest('button[data-action="openUserChatFromMessage"]');
      if (!btn) return;
      const userId = btn.dataset.userid;
      if (!userId) return;
      if (state.activeChat.type !== 'global') return; // requirement: click nick in global -> open chat
      if (userId === state.user.id) {
        toast('–° —Å–æ–±–æ–π —á–∞—Ç –æ—Ç–∫—Ä—ã—Ç—å –Ω–µ–ª—å–∑—è.', 'error');
        return;
      }
      openDm(userId);
    });

    // =========================
    // Profile
    // =========================
    function openProfile() {
      profileError.classList.add('hidden');
      profileError.textContent = '';
      profileNick.value = state.user.nick;
      profileId.value = state.user.id;
      profileAvatar.src = state.user.avatar || defaultAvatarDataUrl(state.user.nick);
      profileAvatarFile.value = '';
      profileModal.classList.remove('hidden');
    }
    function closeProfile() {
      profileModal.classList.add('hidden');
    }

    async function saveProfileChanges() {
      const newNick = (profileNick.value||'').trim();
      if (newNick.length < 2) {
        profileError.textContent = '–ù–∏–∫ —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π (–º–∏–Ω–∏–º—É–º 2 —Å–∏–º–≤–æ–ª–∞).';
        profileError.classList.remove('hidden');
        return;
      }
      const users = loadUsers();
      const clash = users.find(u => u.id !== state.user.id && (u.nick||'').toLowerCase() === newNick.toLowerCase());
      if (clash) {
        profileError.textContent = '–≠—Ç–æ—Ç –Ω–∏–∫ —É–∂–µ –∑–∞–Ω—è—Ç.';
        profileError.classList.remove('hidden');
        return;
      }

      // If nick changed, update passHash binding is based on nick; keep old password? We cannot re-hash without password.
      // So we keep passHash, but login uses current nick in hash input; that would break. We solve by storing passSaltKey (id) and hashing with id.
      // Backward compatibility: migrate on update.

      const idx = users.findIndex(u => u.id === state.user.id);
      if (idx === -1) {
        profileError.textContent = '–ü—Ä–æ—Ñ–∏–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.';
        profileError.classList.remove('hidden');
        return;
      }

      // migrate auth scheme to id-based hash to allow nick change without breaking login
      // If user has passHash2, use it. Otherwise create it from passHash? cannot.
      // We therefore store both: legacy passHashNick (existing) and also passHashId from prompt when changing nick? can't.
      // Practical approach: keep legacy scheme, but when nick changes, require current password.
      // For simplicity, we ask a lightweight prompt.

      const current = users[idx];
      let newPassHash = current.passHash;
      if (newNick !== current.nick) {
        const pw = prompt('–ß—Ç–æ–±—ã —Å–º–µ–Ω–∏—Ç—å –Ω–∏–∫, –≤–≤–µ–¥–∏ —Ç–µ–∫—É—â–∏–π –ø–∞—Ä–æ–ª—å (–∏–Ω–∞—á–µ –≤—Ö–æ–¥ —Å–ª–æ–º–∞–µ—Ç—Å—è):');
        if (pw === null) return; // cancel
        const testHash = await sha256Base64(`${current.nick}:${pw}`);
        if (testHash !== current.passHash) {
          profileError.textContent = '–ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å. –ù–∏–∫ –Ω–µ –∏–∑–º–µ–Ω—ë–Ω.';
          profileError.classList.remove('hidden');
          return;
        }
        newPassHash = await sha256Base64(`${newNick}:${pw}`);
      }

      current.nick = newNick;
      current.passHash = newPassHash;
      current.avatar = profileAvatar.src;
      current.updatedAt = now();
      users[idx] = current;
      saveUsers(users);
      state.user = current;
      setSession(current.id);

      broadcast({ type: 'user:updated', userId: current.id });
      closeProfile();
      renderAll();
      toast('–ü—Ä–æ—Ñ–∏–ª—å —Å–æ—Ö—Ä–∞–Ω—ë–Ω.');
    }

    // =========================
    // WebRTC call handling (tabs demo)
    // =========================
    let ringtone = null;
    function startRingtone() {
      stopRingtone();
      try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const gain = ctx.createGain();
        gain.gain.value = 0.0001;
        gain.connect(ctx.destination);
        const osc = ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = 880;
        osc.connect(gain);
        osc.start();

        let on = false;
        const timer = setInterval(() => {
          on = !on;
          gain.gain.setTargetAtTime(on ? 0.08 : 0.0001, ctx.currentTime, 0.01);
          osc.frequency.setTargetAtTime(on ? 880 : 660, ctx.currentTime, 0.01);
        }, 350);

        ringtone = { ctx, osc, gain, timer };
      } catch {
        ringtone = null;
      }
    }
    function stopRingtone() {
      if (!ringtone) return;
      try {
        clearInterval(ringtone.timer);
        ringtone.gain.gain.setTargetAtTime(0.0001, ringtone.ctx.currentTime, 0.01);
        ringtone.osc.stop();
        ringtone.ctx.close();
      } catch {}
      ringtone = null;
    }

    function setCallUi(inCall) {
      if (inCall) {
        btnCall.classList.add('hidden');
        btnHangup.classList.remove('hidden');
        callOverlay.classList.remove('hidden');
        $('#bannerLimitations').classList.add('hidden');
      } else {
        btnCall.classList.remove('hidden');
        btnHangup.classList.add('hidden');
        callOverlay.classList.add('hidden');
        $('#bannerLimitations').classList.remove('hidden');
        remoteVideo.srcObject = null;
        localVideo.srcObject = null;
      }
    }

    function updateCallButtons() {
      btnToggleMic.textContent = `–ú–∏–∫—Ä–æ—Ñ–æ–Ω: ${state.call.micOn ? '–í–ö–õ' : '–í–´–ö–õ'}`;
      btnToggleCam.textContent = `–ö–∞–º–µ—Ä–∞: ${state.call.camOn ? '–í–ö–õ' : '–í–´–ö–õ'}`;
      btnToggleScreen.textContent = `–≠–∫—Ä–∞–Ω: ${state.call.screenOn ? '–í–ö–õ' : '–í–´–ö–õ'}`;
    }

    async function ensureLocalMedia() {
      // Always get both tracks; user can toggle afterwards.
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
      state.call.localStream = stream;
      localVideo.srcObject = stream;
      state.call.micOn = true;
      state.call.camOn = true;
      updateCallButtons();
      return stream;
    }

    function stopStream(stream) {
      if (!stream) return;
      for (const t of stream.getTracks()) {
        try { t.stop(); } catch {}
      }
    }

    function buildPeerConnection(peerId) {
      const pc = new RTCPeerConnection({
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' },
        ]
      });

      state.call.pc = pc;
      state.call.peerId = peerId;
      state.call.remoteStream = new MediaStream();
      remoteVideo.srcObject = state.call.remoteStream;

      pc.ontrack = (e) => {
        for (const track of e.streams[0].getTracks()) {
          state.call.remoteStream.addTrack(track);
        }
      };
      pc.onicecandidate = (e) => {
        if (e.candidate) {
          broadcast({ type: 'call:ice', from: state.user.id, to: peerId, candidate: e.candidate });
        }
      };
      pc.onconnectionstatechange = () => {
        callStatus.textContent = `–°–æ—Å—Ç–æ—è–Ω–∏–µ: ${pc.connectionState}`;
        if (['failed','disconnected','closed'].includes(pc.connectionState)) {
          // Allow some grace, but for demo we end.
          if (pc.connectionState !== 'closed') {
            // keep overlay; user may hang up
          }
        }
      };

      return pc;
    }

    async function startCall(peerId) {
      if (state.activeChat.type !== 'dm') {
        toast('–í –æ–±—â–∏–π —á–∞—Ç –∑–≤–æ–Ω–∏—Ç—å –Ω–µ–ª—å–∑—è.', 'error');
        return;
      }
      if (peerId === state.user.id) {
        toast('–ù–µ–ª—å–∑—è –∑–≤–æ–Ω–∏—Ç—å —Å–∞–º–æ–º—É —Å–µ–±–µ.', 'error');
        return;
      }
      if (state.call.inCall || state.pendingCall) {
        toast('–£–∂–µ –µ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–π/–≤—Ö–æ–¥—è—â–∏–π –∑–≤–æ–Ω–æ–∫.', 'error');
        return;
      }

      state.call.inCall = true;
      state.call.outgoing = true;
      setCallUi(true);
      updateCallButtons();

      const peer = getUserById(peerId);
      callWith.textContent = `–ó–≤–æ–Ω–æ–∫: ${peer ? peer.nick : peerId}`;
      callStatus.textContent = '–ò—Å—Ö–æ–¥—è—â–∏–π‚Ä¶ –æ–∂–∏–¥–∞–Ω–∏–µ –æ—Ç–≤–µ—Ç–∞';

      const stream = await ensureLocalMedia();
      const pc = buildPeerConnection(peerId);
      for (const track of stream.getTracks()) pc.addTrack(track, stream);

      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);

      broadcast({
        type: 'call:offer',
        from: state.user.id,
        to: peerId,
        sdp: pc.localDescription,
        meta: { ts: now() }
      });
    }

    function showIncomingCall(fromId) {
      const u = getUserById(fromId);
      incomingAvatar.src = (u?.avatar) || defaultAvatarDataUrl(u?.nick || fromId);
      incomingTitle.textContent = '–í—Ö–æ–¥—è—â–∏–π –∑–≤–æ–Ω–æ–∫‚Ä¶';
      incomingSubtitle.textContent = u ? `${u.nick} (${u.id})` : fromId;
      incomingCallModal.classList.remove('hidden');
      startRingtone();
    }
    function hideIncomingCall() {
      incomingCallModal.classList.add('hidden');
      stopRingtone();
    }

    async function acceptIncomingCall() {
      if (!state.pendingCall) return;
      const { from, sdp } = state.pendingCall;
      hideIncomingCall();

      if (state.call.inCall) {
        broadcast({ type: 'call:decline', from: state.user.id, to: from, reason: 'busy' });
        state.pendingCall = null;
        return;
      }

      state.call.inCall = true;
      state.call.outgoing = false;
      setCallUi(true);
      updateCallButtons();

      const peer = getUserById(from);
      callWith.textContent = `–ó–≤–æ–Ω–æ–∫: ${peer ? peer.nick : from}`;
      callStatus.textContent = '–ü—Ä–∏–Ω—è—Ç–∏–µ‚Ä¶';

      const stream = await ensureLocalMedia();
      const pc = buildPeerConnection(from);
      for (const track of stream.getTracks()) pc.addTrack(track, stream);

      await pc.setRemoteDescription(new RTCSessionDescription(sdp));
      state.call.remoteDescSet = true;

      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);

      // flush queued ICE
      if (state.call.iceQueue.length) {
        for (const c of state.call.iceQueue) {
          try { await pc.addIceCandidate(c); } catch {}
        }
        state.call.iceQueue = [];
      }

      broadcast({ type: 'call:answer', from: state.user.id, to: from, sdp: pc.localDescription });
      callStatus.textContent = '–ü–æ–¥–∫–ª—é—á–µ–Ω–æ/–æ–∂–∏–¥–∞–Ω–∏–µ –º–µ–¥–∏–∞‚Ä¶';

      state.pendingCall = null;
    }

    function declineIncomingCall() {
      if (!state.pendingCall) return;
      const { from } = state.pendingCall;
      hideIncomingCall();
      broadcast({ type: 'call:decline', from: state.user.id, to: from, reason: 'declined' });
      state.pendingCall = null;
    }

    async function handleRemoteAnswer(from, sdp) {
      if (!state.call.pc) return;
      if (state.call.peerId !== from) return;
      await state.call.pc.setRemoteDescription(new RTCSessionDescription(sdp));
      state.call.remoteDescSet = true;
      // flush queued ICE
      if (state.call.iceQueue.length) {
        for (const c of state.call.iceQueue) {
          try { await state.call.pc.addIceCandidate(c); } catch {}
        }
        state.call.iceQueue = [];
      }
      callStatus.textContent = '–ü–æ–¥–∫–ª—é—á–µ–Ω–æ/–æ–∂–∏–¥–∞–Ω–∏–µ –º–µ–¥–∏–∞‚Ä¶';
    }

    async function handleRemoteIce(from, candidate) {
      if (!state.call.inCall || state.call.peerId !== from) {
        return;
      }
      const c = new RTCIceCandidate(candidate);
      if (!state.call.pc || !state.call.remoteDescSet) {
        state.call.iceQueue.push(c);
        return;
      }
      try { await state.call.pc.addIceCandidate(c); } catch {}
    }

    function endCall(localInitiated=true) {
      const peerId = state.call.peerId;

      try { if (state.call.pc) state.call.pc.close(); } catch {}
      state.call.pc = null;

      stopStream(state.call.screenStream);
      state.call.screenStream = null;

      stopStream(state.call.localStream);
      state.call.localStream = null;

      state.call.remoteStream = null;
      state.call.peerId = null;
      state.call.inCall = false;
      state.call.outgoing = false;
      state.call.remoteDescSet = false;
      state.call.iceQueue = [];
      state.call.micOn = true;
      state.call.camOn = true;
      state.call.screenOn = false;
      updateCallButtons();

      setCallUi(false);
      renderChatHeader();

      if (localInitiated && peerId) {
        broadcast({ type: 'call:hangup', from: state.user.id, to: peerId });
      }
    }

    async function toggleMic() {
      state.call.micOn = !state.call.micOn;
      if (state.call.localStream) {
        for (const t of state.call.localStream.getAudioTracks()) t.enabled = state.call.micOn;
      }
      updateCallButtons();
    }

    async function toggleCam() {
      state.call.camOn = !state.call.camOn;
      if (state.call.localStream) {
        for (const t of state.call.localStream.getVideoTracks()) t.enabled = state.call.camOn;
      }
      updateCallButtons();
    }

    async function toggleScreen() {
      if (!state.call.inCall || !state.call.pc) return;

      if (!state.call.screenOn) {
        // Enable screen
        try {
          const s = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: false });
          state.call.screenStream = s;
          const screenTrack = s.getVideoTracks()[0];
          if (!screenTrack) return;

          // Replace outgoing video track
          const sender = state.call.pc.getSenders().find(snd => snd.track && snd.track.kind === 'video');
          if (sender) await sender.replaceTrack(screenTrack);

          // Show screen as local preview
          localVideo.srcObject = s;

          state.call.screenOn = true;
          updateCallButtons();

          screenTrack.onended = async () => {
            // revert back
            if (state.call.screenOn) await toggleScreen();
          };
        } catch (e) {
          toast('–ù–µ —É–¥–∞–ª–æ—Å—å –≤–∫–ª—é—á–∏—Ç—å –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—é —ç–∫—Ä–∞–Ω–∞.', 'error');
        }
      } else {
        // Disable screen and revert to camera track
        const pc = state.call.pc;
        const sender = pc.getSenders().find(snd => snd.track && snd.track.kind === 'video');
        const camTrack = state.call.localStream?.getVideoTracks()?.[0] || null;
        try {
          if (sender && camTrack) await sender.replaceTrack(camTrack);
        } catch {}
        stopStream(state.call.screenStream);
        state.call.screenStream = null;
        localVideo.srcObject = state.call.localStream;
        state.call.screenOn = false;
        updateCallButtons();
      }
    }

    // =========================
    // Broadcast handler
    // =========================
    function handleBroadcast(msg) {
      // messages
      if (msg.type === 'msg:global') {
        // ensure persisted already by sender; still re-render
        if (state.user) {
          if (state.activeChat.type === 'global') renderMessages();
        }
        return;
      }

      if (msg.type === 'msg:dm') {
        if (!state.user) return;
        const myId = state.user.id;
        const pair = msg.pair;
        if (!pair || !pair.includes(myId)) return;

        // message should already be in localStorage on sender tab, but receiver tab may not have it.
        // We append if missing.
        const other = pair.split('_').find(x => x !== myId);
        if (!other) return;
        const key = dmKey(myId, other);
        const msgs = loadJson(key, []);
        if (!msgs.some(m => m.id === msg.message.id)) {
          msgs.push(msg.message);
          saveJson(key, msgs);
        }
        renderDmList();
        if (state.activeChat.type==='dm' && state.activeChat.peerId === other) renderMessages();
        return;
      }

      // user updates
      if (msg.type === 'user:updated' || msg.type === 'user:created') {
        if (state.user) {
          // re-render lists and headers
          renderChatHeader();
          renderMessages();
          renderDmList();
          // refresh 'me' only if myself updated
          if (msg.userId === state.user.id) renderMe();
        }
        return;
      }

      // calls
      if (msg.type === 'call:offer') {
        if (!state.user) return;
        if (msg.to !== state.user.id) return;
        if (state.activeChat.type !== 'dm' || state.activeChat.peerId !== msg.from) {
          // auto-open dm so user sees who is calling (but no messages to self)
          if (msg.from !== state.user.id) openDm(msg.from);
        }

        if (state.call.inCall || state.pendingCall) {
          broadcast({ type: 'call:decline', from: state.user.id, to: msg.from, reason: 'busy' });
          return;
        }

        state.pendingCall = { from: msg.from, sdp: msg.sdp, meta: msg.meta };
        showIncomingCall(msg.from);
        return;
      }

      if (msg.type === 'call:answer') {
        if (!state.user) return;
        if (msg.to !== state.user.id) return;
        handleRemoteAnswer(msg.from, msg.sdp);
        return;
      }

      if (msg.type === 'call:ice') {
        if (!state.user) return;
        if (msg.to !== state.user.id) return;
        handleRemoteIce(msg.from, msg.candidate);
        return;
      }

      if (msg.type === 'call:decline') {
        if (!state.user) return;
        if (msg.to !== state.user.id) return;
        toast('–ó–≤–æ–Ω–æ–∫ –æ—Ç–∫–ª–æ–Ω—ë–Ω.', 'error');
        endCall(false);
        return;
      }

      if (msg.type === 'call:hangup') {
        if (!state.user) return;
        if (msg.to !== state.user.id) return;
        toast('–ó–≤–æ–Ω–æ–∫ –∑–∞–≤–µ—Ä—à—ë–Ω.');
        endCall(false);
        return;
      }
    }

    // =========================
    // Input helpers
    // =========================
    function autoGrow(ta) {
      ta.style.height = 'auto';
      ta.style.height = Math.min(140, ta.scrollHeight) + 'px';
    }

    msgInput.addEventListener('input', () => autoGrow(msgInput));

    // =========================
    // Events wiring
    // =========================
    loginForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      setAuthError(loginError, null);
      try {
        const u = await login(loginIdentifier.value, loginPassword.value);
        state.user = u;
        setSession(u.id);
        showApp();
        state.activeChat = { type: 'global', peerId: null };
        renderAll();
      } catch (err) {
        setAuthError(loginError, err.message || String(err));
      }
    });

    registerForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      setAuthError(regError, null);
      try {
        let avatarDataUrl = null;
        if (regAvatar.files && regAvatar.files[0]) {
          avatarDataUrl = await fileToDataUrl(regAvatar.files[0]);
        }
        const u = await register(regNick.value, regPassword.value, avatarDataUrl);
        state.user = u;
        setSession(u.id);
        showApp();
        state.activeChat = { type: 'global', peerId: null };
        renderAll();
        toast('–ê–∫–∫–∞—É–Ω—Ç —Å–æ–∑–¥–∞–Ω.');
      } catch (err) {
        setAuthError(regError, err.message || String(err));
      }
    });

    btnLogout.addEventListener('click', () => {
      // end call and logout
      if (state.pendingCall) {
        hideIncomingCall();
        state.pendingCall = null;
      }
      if (state.call.inCall) endCall(true);
      state.user = null;
      clearSession();
      showAuth();
      toast('–í—ã –≤—ã—à–ª–∏.');
    });

    btnProfile.addEventListener('click', openProfile);

    document.addEventListener('click', (e) => {
      const btn = e.target.closest('[data-close]');
      if (!btn) return;
      const what = btn.dataset.close;
      if (what === 'emoji') hideEmoji();
      if (what === 'profile') closeProfile();
    });

    btnCancelProfile.addEventListener('click', closeProfile);

    profileAvatarFile.addEventListener('change', async () => {
      const f = profileAvatarFile.files?.[0];
      if (!f) return;
      if (f.size > 3.5 * 1024 * 1024) {
        toast('–§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π (–º–∞–∫—Å ~3.5MB).', 'error');
        profileAvatarFile.value = '';
        return;
      }
      profileAvatar.src = await fileToDataUrl(f);
    });

    btnRemoveAvatar.addEventListener('click', () => {
      profileAvatar.src = defaultAvatarDataUrl(profileNick.value || state.user.nick || state.user.id);
      profileAvatarFile.value = '';
    });

    btnCopyId.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(state.user.id);
        toast('ID —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω.');
      } catch {
        toast('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å (—Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è –±—Ä–∞—É–∑–µ—Ä–∞).', 'error');
      }
    });

    btnSaveProfile.addEventListener('click', saveProfileChanges);

    btnGlobal.addEventListener('click', openGlobal);
    btnRefreshChats.addEventListener('click', renderDmList);

    searchInput.addEventListener('input', () => {
      const q = (searchInput.value||'').trim().toLowerCase();
      if (!q) { searchResults.classList.add('hidden'); searchResults.innerHTML=''; return; }
      const items = loadUsers()
        .filter(u => u.id !== state.user.id)
        .filter(u => (u.nick||'').toLowerCase().includes(q) || (u.id||'').toLowerCase().includes(q))
        .slice(0, 12);
      renderSearchResults(items);
    });

    btnSearchClear.addEventListener('click', () => {
      searchInput.value = '';
      searchResults.classList.add('hidden');
      searchResults.innerHTML = '';
      searchInput.focus();
    });

    btnEmoji.addEventListener('click', () => {
      showEmoji();
    });

    btnSend.addEventListener('click', () => sendMessage(msgInput.value));
    msgInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage(msgInput.value);
      }
    });

    btnCall.addEventListener('click', async () => {
      if (state.activeChat.type !== 'dm') {
        toast('–í –æ–±—â–∏–π —á–∞—Ç –∑–≤–æ–Ω–∏—Ç—å –Ω–µ–ª—å–∑—è.', 'error');
        return;
      }
      await startCall(state.activeChat.peerId);
    });
    btnHangup.addEventListener('click', () => endCall(true));
    btnHangup2.addEventListener('click', () => endCall(true));

    btnDecline.addEventListener('click', declineIncomingCall);
    btnAccept.addEventListener('click', acceptIncomingCall);

    btnToggleMic.addEventListener('click', toggleMic);
    btnToggleCam.addEventListener('click', toggleCam);
    btnToggleScreen.addEventListener('click', toggleScreen);

    // =========================
    // Startup
    // =========================
    function migrateUserAvatars() {
      // ensure all users have avatar
      const users = loadUsers();
      let changed = false;
      for (const u of users) {
        if (!u.avatar) { u.avatar = defaultAvatarDataUrl(u.nick || u.id); changed = true; }
      }
      if (changed) saveUsers(users);
    }

    function init() {
      migrateUserAvatars();
      renderEmojiGrid();
      autoGrow(msgInput);

      const session = loadSession();
      if (session?.userId) {
        const u = getUserById(session.userId);
        if (u) {
          state.user = u;
          showApp();
          state.activeChat = { type: 'global', peerId: null };
          renderAll();
          return;
        }
      }
      showAuth();
    }

    // Prevent leaving active call without notifying
    window.addEventListener('beforeunload', () => {
      if (state.call.inCall && state.call.peerId) {
        try { broadcast({ type: 'call:hangup', from: state.user?.id, to: state.call.peerId }); } catch {}
      }
    });

    init();
  </script>
</body>
</html>
